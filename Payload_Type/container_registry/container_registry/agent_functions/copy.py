from mythic_container.MythicCommandBase import *
from mythic_container.MythicRPC import *
from container_registry.agent_functions.shared import get_arg_or_build_value, get_registry_proto_url
import asyncio
from tempfile import NamedTemporaryFile


class CopyArguments(TaskArguments):
    def __init__(self, command_line, **kwargs):
        super().__init__(command_line, **kwargs)
        self.args = [
            CommandParameter(
                name="source",
                cli_name="Payload",
                display_name="Payload",
                description="Source payload file",
                type=ParameterType.ChooseOne,
                dynamic_query_function=self.get_payloads,
                parameter_group_info=[ParameterGroupInfo(
                    required=True
                )]
            ),
            CommandParameter(
                name="destination_name",
                type=ParameterType.String,
                description="Destination image name, including the tag, for the configured repository (e.g. alpine:latest)",
                parameter_group_info=[ParameterGroupInfo(
                    required=True
                )]
            ),
            CommandParameter(
                name="DEST_USERNAME",
                type=ParameterType.String,
                description="Destination registry username (optional) -- leave empty to use from provided build parameters",
                parameter_group_info=[ParameterGroupInfo(required=False)],
                default_value="",
            ),
            CommandParameter(
                name="DEST_PASSWORD",
                type=ParameterType.String,
                description="Destination registry password/token (optional) -- leave empty to use from provided build parameters",
                parameter_group_info=[ParameterGroupInfo(required=False)],
                default_value="",
            ),
            CommandParameter(
                name="DEST_INSECURE",
                type=ParameterType.Boolean,
                description="Allow insecure destination connections",
                parameter_group_info=[ParameterGroupInfo(required=False)],
                default_value=False,
            ),
        ]

    # https://github.com/MythicAgents/Apollo/blob/64946d938bd7328e80807e264081407d6b7f9185/Payload_Type/apollo/apollo/mythic/agent_functions/inject.py#L43-L64
    async def get_payloads(self, inputMsg: PTRPCDynamicQueryFunctionMessage) -> PTRPCDynamicQueryFunctionMessageResponse:
        fileResponse = PTRPCDynamicQueryFunctionMessageResponse(Success=False)
        payload_search = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
            CallbackID=inputMsg.Callback,
            PayloadTypes=["container_wrapper"],
            IncludeAutoGeneratedPayloads=False,
            BuildParameters=[MythicRPCPayloadSearchBuildParameter(PayloadType="container_wrapper")]
        ))

        if payload_search.Success:
            file_names = []
            for f in payload_search.Payloads:
                value = f"{f.Filename} - {f.Description}"
                if value not in file_names:
                    file_names.append(value)
            fileResponse.Success = True
            file_names.reverse()
            fileResponse.Choices = file_names
            return fileResponse
        else:
            fileResponse.Error = payload_search.Error
            return fileResponse

    async def parse_arguments(self):
        if len(self.command_line) == 0:
            raise ValueError("Must supply arguments")
        if self.command_line[0] == "{":
            self.load_args_from_json_string(self.command_line)
        else:
            raise ValueError("Require JSON arguments")


class Copy(CommandBase):
    cmd = "copy"
    needs_admin = False
    help_cmd = "copy"
    description = "Upload a container wrapper image into registry using skopeo copy"
    version = 1
    supported_ui_features = ["container_registry:copy"]
    author = "@elreydetoda"
    argument_class = CopyArguments
    attackmapping = []

    async def create_go_tasking(self, taskData: MythicCommandBase.PTTaskMessageAllData) -> MythicCommandBase.PTTaskCreateTaskingMessageResponse:
        response = MythicCommandBase.PTTaskCreateTaskingMessageResponse(
            TaskID=taskData.Task.ID,
            Success=False,
            Completed=True,
        )

        try:
            # Build skopeo command
            cmd = ["skopeo", "copy"]

            # Add destination authentication if provided
            dest_username = get_arg_or_build_value(taskData, "DEST_USERNAME")
            dest_password = get_arg_or_build_value(taskData, "DEST_PASSWORD")
            if dest_username and dest_password:
                cmd.extend(["--dest-creds", f"{dest_username}:{dest_password}"])

            dest_insecure = get_arg_or_build_value(taskData, "DEST_INSECURE")
            if dest_insecure:
                cmd.append("--dest-tls-verify=false")

            # https://github.com/MythicAgents/Apollo/blob/64946d938bd7328e80807e264081407d6b7f9185/Payload_Type/apollo/apollo/mythic/agent_functions/inject.py#L141C9-L159
            string_payload = [x.strip() for x in taskData.args.get_arg("source").split(" - ")]
            logger.debug(f"{string_payload=}")
            filename = string_payload[0]
            desc = string_payload[1]
            payload_search = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
                CallbackID=taskData.Callback.ID,
                PayloadTypes=["container_wrapper"],
                Filename=filename,
                Description=desc,
                IncludeAutoGeneratedPayloads=False,
                BuildParameters=[MythicRPCPayloadSearchBuildParameter(PayloadType="container_wrapper")]
            ))
            logger.debug(f"{payload_search=}")

            if not payload_search.Success:
                raise Exception("Failed to find payload: {}".format(taskData.args.get_arg("template")))

            if len(payload_search.Payloads) == 0:
                raise Exception("No payloads found matching {}".format(taskData.args.get_arg("template")))
            str_uuid = payload_search.Payloads[0].UUID

            payload_contents = await SendMythicRPCFileGetContent(
                MythicRPCFileGetContentMessage(AgentFileID=str_uuid)
            )
            if not payload_contents.Success:
                raise Exception("Failed to get payload contents for UUID: {}".format(str_uuid))

            with NamedTemporaryFile() as tempFile:
                payload_path = Path(tempFile.name)
            
                payload_path.write_bytes(payload_contents.Content)

                # Add source and destination
                source = f"oci-archive:{payload_path}"
                destination_name = taskData.args.get_arg("destination_name")
                destination = f"{get_registry_proto_url(taskData=taskData,)}/{destination_name}"
                cmd.extend([source, destination])

                # Execute skopeo command
                logger.debug(f"{cmd=}")
                proc = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
                stdout, stderr = await proc.communicate()

                # Process output
                if proc.returncode == 0:
                    output = stdout.decode()
                    error_output = stderr.decode()
                    result = f"Successfully copied {source} ({payload_search.Payloads[0].Filename}) to {destination}"
                    if output:
                        result += f"\n\nOutput:\n{output}"
                    if error_output:
                        result += f"\n\nInfo:\n{error_output}"

                    await SendMythicRPCResponseCreate(
                        MythicRPCResponseCreateMessage(
                            TaskID=taskData.Task.ID,
                            Response=result.encode(),
                        )
                    )
                    response.Success = True
                else:
                    error_msg = stderr.decode()
                    await SendMythicRPCResponseCreate(
                        MythicRPCResponseCreateMessage(
                            TaskID=taskData.Task.ID,
                            Response=f"Error copying {source} to {destination}:\n{error_msg}".encode(),
                        )
                    )

        except Exception as e:
            await SendMythicRPCResponseCreate(
                MythicRPCResponseCreateMessage(
                    TaskID=taskData.Task.ID,
                    Response=f"Exception occurred: {str(e)}".encode(),
                )
            )

        return response
